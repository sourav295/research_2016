"""
    A bit more detailed set of components to use in packet switching
    queueing experiments.
    Copyright 2014 Greg M. Bernstein
    Released under the MIT license
"""
import simpy
import random
import copy
from simpy.core import BoundClass
from simpy.resources import base
from routing import Network_Components, Priority_Queue
import logging
from itertools import cycle
from configure import GlobalConfiguration

simulation_logger = logging.getLogger("simulation")
packet_logger = logging.getLogger("packets")

class Packet(object):
    """ A very simple class that represents a packet.
        This packet will run thrdough a queue at a switch output port.
        We use a float to represent the size of the packet in bytes so that
        we can compare to ideal M/M/1 queues.

        Parameters
        ----------
        time : float
            the time the packet arrives at the output queue.
        size : float
            the size of the packet in bytes
        id : int
            an identifier for the packet
        src, dst : int
            identifiers for source and destination
        flow_id : int
            small integer that can be used to identify a flow
    """
    
    all_packets_generated = []
    
    
    def __init__(self, time, size, id, src="a", dst="z", flow_id=0, priority=0):
        
        
        self.time = time
        self.size = size
        self.id = id
        self.src = src
        self.dst = dst
        self.flow_id = flow_id
        self.priority = priority
        self.log_var = self.__repr__()
        self.explicit_path = Network_Components.findExplicitPath(self.src, self.dst)
        self.explicit_path_pointer = 0 #current location of the packet
        #print self.explicit_path
        
        self.log(str(self.explicit_path))
        self.log("\nPacket to be sent to Router- {}".format(self.next_hop()))
        
        #keep a record of all paths
        Packet.all_packets_generated.append(self)
        
        
    def __repr__(self):
        return "id: {}, src: {}, dst: {}, time: {}, size: {}, prio: {}".\
            format(self.id, self.src, self.dst, self.time, self.size, self.priority)
            
    def increment_explicit_path_pointer(self):
        self.explicit_path_pointer = self.explicit_path_pointer + 1
        
    def next_hop(self):
        return self.explicit_path[self.explicit_path_pointer + 1]
    
    def verify_current_position(self, this_network_component):
        return this_network_component == self.explicit_path[self.explicit_path_pointer]
    
    def log(self, value):
        self.log_var += "\n" + value
        
    @staticmethod
    def log_to_file():
        for pck in Packet.all_packets_generated:
            packet_logger.info("========================================")
            packet_logger.info(pck.log_var)
            packet_logger.info("========================================")
            
    @staticmethod
    def getStats():
        return len(Packet.all_packets_generated)            
        
    

class PacketGenerator(object):
    """ Generates packets with given inter-arrival time distribution.
        Set the "out" member variable to the entity to receive the packet.

        Parameters
        ----------
        env : simpy.Environment
            the simulation environment
        adist : function
            a no parameter function that returns the successive inter-arrival times of the packets
        sdist : function
            a no parameter function that returns the successive sizes of the packets
        initial_delay : number
            Starts generation after an initial delay. Default = 0
        finish : number
            Stops generation at the finish time. Default is infinite


    """
    def __init__(self, env, id,  adist, sdist, initial_delay=0, finish=float("inf"), flow_id=0, rate = 0):
        self.id = id
        self.env = env
        self.adist = adist
        self.sdist = sdist
        self.initial_delay = initial_delay
        self.finish = finish
        self.rate = rate #port rate
        self.out = {} 
        self.packets_sent = 0
        self.action = env.process(self.run())  # starts the run() method as a SimPy process
        self.flow_id = flow_id

    def run(self):
        """The generator function used in simulations.
        """
        yield self.env.timeout(self.initial_delay)
        while self.env.now < self.finish:
            # wait for next transmission
            random_dest = Network_Components.selectRandomSink()
            random_prio = random.randint(1,GlobalConfiguration.nPrioLevels)
            yield self.env.timeout(self.adist())
            p = Packet(self.env.now, self.sdist(), self.packets_sent, src=self, dst=random_dest, flow_id=self.flow_id, priority=random_prio)
            simulation_logger.info("Generated By: {:4} ID: {:4} Msg: [{}]".format(self, p.id, p))
            self.packets_sent += 1
            #transmission delay
            #yield self.env.timeout(p.size*8.0/self.rate)  #Start Transmitting
            
            p.increment_explicit_path_pointer()
            
            self.out.put(p)
            


class PacketSink(object):
    """ Receives packets and collects delay information into the
        waits list. You can then use this list to look at delay statistics.

        Parameters
        ----------
        env : simpy.Environment
            the simulation environment
        debug : boolean
            if true then the contents of each packet will be printed as it is received.
        rec_arrivals : boolean
            if true then arrivals will be recorded
        absolute_arrivals : boolean
            if true absolute arrival times will be recorded, otherwise the time between consecutive arrivals
            is recorded.
        rec_waits : boolean
            if true waiting time experienced by each packet is recorded
        selector: a function that takes a packet and returns a boolean
            used for selective statistics. Default none.

    """
    def __init__(self, env, rec_arrivals=False, absolute_arrivals=False, rec_waits=True, debug=False, selector=None):
        self.store = simpy.Store(env)
        self.env = env
        self.rec_waits = rec_waits
        self.rec_arrivals = rec_arrivals
        self.absolute_arrivals = absolute_arrivals
        self.waits = []
        self.arrivals = []
        self.debug = debug
        self.action = env.process(self.run())  # starts the run() method as a SimPy process
        self.packets_rec = 0
        self.bytes_rec = 0
        self.selector = selector

    def run(self):
        last_arrival = 0.0
        while True:
            msg = (yield self.store.get())
            if not self.selector or self.selector(msg):
                now = self.env.now
                if self.rec_waits:
                    self.waits.append(self.env.now - msg.time)
                if self.rec_arrivals:
                    if self.absolute_arrivals:
                        self.arrivals.append(now)
                    else:
                        self.arrivals.append(now - last_arrival)
                    last_arrival = now
                self.packets_rec += 1
                self.bytes_rec += msg.size
                if self.debug:
                    simulation_logger.info("=======================================")
                    simulation_logger.info("Received at: {:10} By: {:10} Msg: [{:20}]".format(self.env.now, self, msg))
                    simulation_logger.info(msg.explicit_path)
                    simulation_logger.info("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
                    

    def put(self, pkt):
        pkt.log("Packet received at sink: {}, time: {}".format( self, self.env.now))
        self.store.put(pkt)


class Cable(object):
    """This class represents the propagation through a cable."""
    
    def __init__(self, env, delay):
        self.env = env
        self.delay = delay
        self.store = simpy.Store(env)
        self.out = None

    def latency(self, value):
        temp_time = self.env.now
        
        yield self.env.timeout(self.delay)
    
        propagation_delay = self.env.now - temp_time
        value.log("<<Propagation delay over core office links: {}>>".format(propagation_delay))
        self.out.put(value)

    def put(self, value):
        self.env.process(self.latency(value))
        
        
                

class SwitchPort(object):
    
    def __init__(self, env, rate, qlimit=None, debug=False):
        #self.store = simpy.Store(env)
        self.rate = rate
        self.env = env
        self.out = {}
        self.packets_rec = 0
        self.packets_drop = 0
        self.qlimit = qlimit
        self.byte_size = 0              # Current size of the queue in bytes
        self.debug = debug
        self.busy = 0                   # Used to track if a packet is currently being sent
        self.routing_processor = None
        self.wait = None                # wait a pck when they are not available
        self.delay_factor = 1           #Delay factor introduced to distinguish between NFV and SDN
        
        self.action = env.process(self.run())  # starts the run() method as a SimPy process
        
        
    def run(self):
        priority_queues     = self.routing_processor.get_all_prio_queues(self)
        nOfQueues           = len(priority_queues)
        msg_retreval_fail   = 0
        #Round Robin
        for queue_index in cycle(range(nOfQueues)):
            queue_selected  = priority_queues[queue_index]
            msg_retreived   = False
            
            if not queue_selected.is_empty():                   #if store is not empty
                msg = queue_selected.get()
                if GlobalConfiguration.queue_log:
                    Priority_Queue.notify_pcks(msg, self, priority_queues, self.env.now, "!** Pck selected [{}]".format(str(msg)))
                msg_retreived = True
            else:                                               #failed attempt to retreive pck
                msg_retreval_fail += 1
                
            if msg_retreived:                                   #now - transmit msg
                env_time_before_transmission = self.env.now
                msg.log("Packet on out port {} at {}".format(self, env_time_before_transmission))
                msg_retreval_fail = 0                           #refresh the failure list
                self.busy = 1
                self.byte_size -= msg.size                      
                
                #Delay factor employed distinguish it from SDN or NFV or physical
                yield self.env.timeout(msg.size * 8.0 * self.delay_factor / self.rate)  #Start Transmitting
                #print self.delay_factor
                transmission_time = self.env.now - env_time_before_transmission
                msg.log("Packet transmitted to cabel at: {} duration: {}".format(self.env.now, transmission_time))
                if GlobalConfiguration.queue_log:
                    Priority_Queue.notify_pcks(msg, self, priority_queues, self.env.now, "!** Pck transmitted [{}]".format(str(msg)))
                msg.log("------")
       
                msg.increment_explicit_path_pointer()
                self.out.put(msg)
                self.busy = 0
            elif msg_retreval_fail >= nOfQueues:                #stores are empty, passivate until notified
                yield self.wait
                msg_retreval_fail = 0                           #refresh the failure list
                
    def put(self, pkt):
        self.packets_rec += 1
        tmp = self.byte_size + pkt.size
        
        pkt.log("------")
        pkt.log("Packet arrived - Interface: {} Time: {}".format(self, self.env.now))
        if self.qlimit is None:
            self.byte_size = tmp
            return self.routing_processor.put(pkt, self)
        if tmp >= self.qlimit:
            self.packets_drop += 1
            pkt.log("Packet dropped - Queue Limit reached")
            return
        else:
            self.byte_size = tmp
            return self.routing_process.put(pkt, self)
            
    def set_routing_processor(self, routing_processor):
        self.routing_processor = routing_processor
    def get_routing_processor(self):
        return self.routing_processor
    def addInterface(self, next_hop):
        self.routing_processor.add_interface(next_hop, self)
    def set_delay_factor(self, delay_fact):
        self.delay_factor = delay_fact
        
        
class MuxponderPort(object):
    
    def __init__(self, env, rate, is_upstream_bound_Inf):
        self.rate = rate
        self.env  = env
        self.out  = None
        
        self.is_upstream_bound_Inf  = is_upstream_bound_Inf
        self.muxponder_processor    = None
        
        self.action = env.process(self.run())  # starts the run() method as a SimPy process
        
    def run(self):
        while True:
            #retreive msg from store
            store = self.muxponder_processor.getStore(self)
            msg = (yield store.get())
            
            env_time_before_transmission = self.env.now
            msg.log("Packet on out port {} at {}".format(self, env_time_before_transmission))
            
            #transmit msg onto cabel
            yield self.env.timeout(msg.size*8.0/self.rate)
            
            transmission_time = self.env.now - env_time_before_transmission
            msg.log("Packet transmitted to cabel at: {} duration: {}".format(self.env.now, transmission_time))
            msg.log("--++--")
            
            msg.increment_explicit_path_pointer()
            self.out.put(msg)
            
    def put(self, pkt):
        
        pkt.log("--++--")
        pkt.log("Packet arrived - Mux Ponder Interface: {} Time: {}".format(self, self.env.now))
        store = self.muxponder_processor.putStore(pkt.next_hop(), self)
        return store.put(pkt)
    
    def set_muxponding_processor(self, muxponding_processor):
        self.muxponder_processor = muxponding_processor
    def get_muxponding_processor(self):
        return self.muxponder_processor
    def addInterface(self, next_hop):
        self.muxponder_processor.add_interface(next_hop, self)
